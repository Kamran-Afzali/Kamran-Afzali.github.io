 
# Agent-Based Modeling with Mesa: Complete Curriculum


# Agent-Based Modeling with Mesa: Complete Curriculum

| **Post #** | **Title** | **Main Concepts** | **Core Model** | **Mesa Components & Code** | **Key Examples** | **Target Audience** | **Prerequisites** | **Learning Outcomes** |
|------------|-----------|-------------------|----------------|----------------------------|------------------|-------------------|-------------------|----------------------|
| **1** | **"Digital Societies: Introduction to Agent-Based Modeling"** | Individual agents, emergence, complex systems, bottom-up modeling | Schelling's Segregation Model | `Agent`, `Model`, `RandomActivation`, `MultiGrid`<br>```python<br>class SchellingAgent(Agent):<br>    def __init__(self, unique_id, model, agent_type):<br>        super().__init__(unique_id, model)<br>        self.type = agent_type<br>``` | Residential segregation, social clustering, tipping points | General audience, social scientists | Basic Python | Understand core ABM concepts and Mesa architecture. Create a basic spatial model with emergent patterns. |
| **2** | **"Your First Digital Agents: Mesa Basics and Simple Models"** | Agent class, model setup, step functions, basic scheduling | Random Walker Model | `Agent.step()`, `Model.__init__()`, `RandomActivation`<br>```python<br>def step(self):<br>    possible_steps = self.model.grid.get_neighborhood(<br>        self.pos, moore=True, include_center=False)<br>    new_position = self.random.choice(possible_steps)<br>    self.model.grid.move_agent(self, new_position)<br>``` | Random walk agents, diffusion patterns, Brownian motion | Programming beginners, students | Python basics, OOP concepts | Master basic Mesa structure. Implement agent movement and basic behaviors. Understand scheduling mechanisms. |
| **3** | **"Space Matters: Grids, Neighborhoods, and Spatial Dynamics"** | Grid spaces, Moore/Von Neumann neighborhoods, spatial interactions | Conway's Game of Life | `MultiGrid`, `SingleGrid`, `get_neighbors()`<br>```python<br>neighbors = self.model.grid.get_neighbors(<br>    self.pos, moore=True, include_center=False)<br>live_neighbors = sum(1 for neighbor in neighbors <br>                    if neighbor.alive)<br>``` | Cellular automata, emergent complexity from simple rules | STEM students, modelers | Mesa basics | Implement spatial rules and neighborhood interactions. Visualize cellular automata dynamics. |
| **4** | **"Resource Competition: Ecological Dynamics in Discrete Space"** | Multi-agent types, reproduction, death, resource competition | Predator-Prey (Wolf-Sheep) Model | Multiple agent classes, lifecycle management<br>```python<br>class Wolf(Agent):<br>    def hunt(self):<br>        cellmates = self.model.grid.get_cell_list_contents([self.pos])<br>        sheep = [obj for obj in cellmates if isinstance(obj, Sheep)]<br>        if len(sheep) > 0:<br>            sheep_to_eat = self.random.choice(sheep)<br>            self.model.grid.remove_agent(sheep_to_eat)<br>``` | Wolf-sheep ecosystem, population cycles, predator-prey dynamics | Biology students, ecologists | Mesa fundamentals | Model multi-species interactions. Implement birth/death processes. Analyze population dynamics. |
| **5** | **"Wealth and Markets: Economic Agent Interactions"** | Resource exchange, wealth distribution, market mechanisms | Sugarscape / Boltzmann Wealth Model | Agent-agent interactions, resource transfer<br>```python<br>def trade(self, other_agent):<br>    if self.wealth > 0 and other_agent.wealth > 0:<br>        trade_amount = min(self.wealth, other_agent.wealth)<br>        transfer = self.random.randint(0, trade_amount)<br>        self.wealth -= transfer<br>        other_agent.wealth += transfer<br>``` | Wealth inequality, economic segregation, market dynamics | Economics students, complexity researchers | Statistics basics | Model economic interactions and wealth flows. Analyze inequality emergence. Implement trading mechanisms. |
| **6** | **"Following the Crowd: Flocking and Swarm Intelligence"** | Collective behavior, local rules, swarm dynamics, continuous space | Boids Flocking Model | `ContinuousSpace`, vector mathematics<br>```python<br>def separate(self, neighbors):<br>    separation_vector = np.array([0.0, 0.0])<br>    for neighbor in neighbors:<br>        if self.pos != neighbor.pos:<br>            diff = np.array(self.pos) - np.array(neighbor.pos)<br>            separation_vector += diff / np.linalg.norm(diff)<br>    return separation_vector<br>``` | Bird flocks, fish schools, robot swarms, traffic flow | AI researchers, biologists | Vector math, Mesa spatial | Implement continuous space models. Create emergent collective behavior from local rules. |
| **7** | **"Contagion and Networks: Epidemic Spreading Models"** | Disease dynamics, network epidemiology, state transitions | SIR Epidemic Model | `NetworkGrid` or `MultiGrid`, state transitions<br>```python<br>def infect(self):<br>    neighbors = self.model.grid.get_neighbors(<br>        self.pos, moore=True, include_center=False)<br>    susceptible_neighbors = [agent for agent in neighbors <br>                           if agent.state == 'S']<br>    for neighbor in susceptible_neighbors:<br>        if self.random.random() < self.model.infection_rate:<br>            neighbor.state = 'I'<br>``` | COVID-19 spread, information epidemics, social contagion | Public health, network scientists | Probability theory | Implement epidemic models with state transitions. Model contagion on networks. Analyze outbreak dynamics. |
| **8** | **"Information Cascades: Opinion Dynamics and Social Influence"** | Social networks, opinion formation, cascade models | Voter Model / Opinion Dynamics | `NetworkGrid`, opinion updating<br>```python<br>def update_opinion(self):<br>    neighbors = self.model.grid.get_neighbors(self.unique_id)<br>    if neighbors:<br>        neighbor_opinions = [n.opinion for n in neighbors]<br>        avg_opinion = np.mean(neighbor_opinions)<br>        self.opinion += self.influence_rate * (avg_opinion - self.opinion)<br>``` | Social media dynamics, voting behavior, rumor spreading | Political scientists, sociologists | Graph theory basics | Model opinion formation on networks. Implement social influence mechanisms. Analyze consensus and polarization. |
| **9** | **"Strategic Interactions: Game Theory and Cooperation"** | Game theory, cooperation, evolutionary strategies | Iterated Prisoner's Dilemma | Strategy classes, payoff matrices<br>```python<br>def play_game(self, opponent):<br>    my_move = self.strategy.get_move(opponent)<br>    opp_move = opponent.strategy.get_move(self)<br>    payoff = self.payoff_matrix[my_move][opp_move]<br>    self.score += payoff<br>    self.history.append((my_move, opp_move))<br>``` | Cooperation evolution, spatial games, tournament dynamics | Game theorists, evolutionary biologists | Game theory basics | Implement strategic interactions. Model strategy evolution. Analyze cooperation emergence. |
| **10** | **"Learning Agents: Adaptation and Intelligence"** | Agent learning, reinforcement, memory, adaptation | Q-Learning Agents | Agent memory, learning algorithms<br>```python<br>def update_q_value(self, state, action, reward, next_state):<br>    old_q = self.q_table.get((state, action), 0)<br>    next_max = max(self.q_table.get((next_state, a), 0) <br>                  for a in self.actions)<br>    new_q = old_q + self.learning_rate * <br>            (reward + self.discount * next_max - old_q)<br>    self.q_table[(state, action)] = new_q<br>``` | Adaptive markets, learning in games, AI agent behavior | AI researchers, adaptive systems | Machine learning basics | Implement learning agents. Compare adaptive vs. fixed strategies. Model bounded rationality. |
| **11** | **"Measuring Emergence: Data Collection and Analysis"** | Data collectors, metrics computation, statistical analysis | Enhanced Schelling with Analytics | `DataCollector`, statistical measures<br>```python<br>datacollector = DataCollector(<br>    model_reporters={<br>        "Segregation_Index": compute_segregation,<br>        "Average_Happiness": lambda m: np.mean([a.happy for a in m.schedule.agents])<br>    },<br>    agent_reporters={"Happy": "happy", "Type": "type"}<br>)<br>``` | Segregation indices, Gini coefficients, network measures | Data scientists, researchers | Statistics, data analysis | Implement comprehensive data collection. Compute emergence metrics. Analyze model outputs statistically. |
| **12** | **"Beautiful Simulations: Visualization and Interactive Models"** | Model visualization, real-time plotting, web interfaces | Interactive Multi-Model Dashboard | `mesa.visualization`, `CanvasGrid`, `ChartModule`<br>```python<br>server = ModularServer(<br>    MyModel,<br>    [grid, chart],<br>    "My Model",<br>    model_params<br>)<br>server.port = 8521<br>``` | Interactive segregation demo, real-time epidemic tracker | Educators, science communicators | Web technologies helpful | Create interactive visualizations. Build web-based model interfaces. Design effective scientific communication tools. |
| **13** | **"Parameter Spaces: Batch Runs and Sensitivity Analysis"** | Parameter sweeps, statistical analysis, model validation | Multi-Parameter Epidemic Analysis | `BatchRunner`, parameter exploration<br>```python<br>batch_run = BatchRunner(<br>    SIRModel,<br>    {"infection_rate": np.arange(0.1, 1.0, 0.1),<br>     "recovery_rate": np.arange(0.1, 0.5, 0.05)},<br>    iterations=50,<br>    max_steps=200<br>)<br>batch_run.run_all()<br>``` | Parameter sensitivity, model robustness, threshold analysis | Computational researchers | Statistical analysis | Conduct systematic parameter exploration. Perform sensitivity analysis. Identify critical model thresholds. |
| **14** | **"Validation and Calibration: Ensuring Model Credibility"** | Model validation, empirical comparison, uncertainty quantification | Calibrated Urban Growth Model | Statistical testing, calibration methods<br>```python<br>def calibrate_model(empirical_data, param_bounds):<br>    def objective(params):<br>        model_output = run_model_with_params(params)<br>        return mean_squared_error(empirical_data, model_output)<br>    result = minimize(objective, bounds=param_bounds)<br>    return result.x<br>``` | Model-data comparison, goodness-of-fit, validation metrics | Academic researchers, consultants | Statistics, domain expertise | Calibrate models to real data. Assess model validity and uncertainty. Apply statistical validation methods. |
| **15** | **"Multi-Level Modeling: Agents, Groups, and Hierarchies"** | Hierarchical structures, multi-scale dynamics, nested agents | Organizational Network Model | Multi-level scheduling, group behaviors<br>```python<br>class Department(Agent):<br>    def __init__(self, unique_id, model):<br>        super().__init__(unique_id, model)<br>        self.employees = []<br>        self.budget = 0<br>    def step(self):<br>        for employee in self.employees:<br>            employee.step()<br>        self.update_department_metrics()<br>``` | Corporate hierarchies, institutional dynamics, multi-scale systems | Organizational scientists | Complex systems theory | Model hierarchical agent structures. Implement multi-level interactions. Analyze cross-scale dynamics. |
| **16** | **"Temporal Dynamics: Memory, Delays, and Path Dependence"** | Historical dependence, agent memory, temporal patterns | Market with Memory Effects | Agent history tracking, temporal analysis<br>```python<br>class MemoryAgent(Agent):<br>    def __init__(self, unique_id, model, memory_length=10):<br>        super().__init__(unique_id, model)<br>        self.memory = deque(maxlen=memory_length)<br>        self.decisions_history = []<br>    def make_decision(self):<br>        recent_outcomes = list(self.memory)[-5:]<br>        decision = self.strategy(recent_outcomes)<br>        return decision<br>``` | Path-dependent evolution, market bubbles, historical effects | Economists, complex systems researchers | Time series analysis | Implement agents with memory and history. Model path-dependent processes. Analyze temporal patterns in behavior. |
| **17** | **"Hybrid Models: Combining ABM with Other Approaches"** | System dynamics integration, machine learning hybrid models | ABM-ML Epidemic Forecast | Integration with external libraries<br>```python<br>import networkx as nx<br>from sklearn.ensemble import RandomForestRegressor<br><br>class HybridAgent(Agent):<br>    def __init__(self, unique_id, model, ml_predictor):<br>        super().__init__(unique_id, model)<br>        self.predictor = ml_predictor<br>    def predict_and_act(self, features):<br>        prediction = self.predictor.predict([features])[0]<br>        return self.act_on_prediction(prediction)<br>``` | ML-enhanced agents, ABM-SD integration, multi-paradigm models | Advanced modelers, interdisciplinary researchers | Multiple modeling paradigms | Combine ABM with machine learning and system dynamics. Create hybrid modeling approaches. Integrate multiple analytical frameworks. |
| **18** | **"Beyond Mesa: Advanced Techniques and Real-World Applications"** | Performance optimization, large-scale models, deployment | Scalable Urban Simulation | Performance optimization, parallel processing<br>```python<br>import numba<br>from multiprocessing import Pool<br><br>@numba.jit<br>def fast_neighbor_calculation(positions, radius):<br>    # Optimized spatial calculations<br>    return neighbor_matrix<br><br>def parallel_model_run(params):<br>    model = MyModel(**params)<br>    model.run_model(steps=1000)<br>    return model.datacollector.get_model_vars_dataframe()<br>``` | Urban planning models, large-scale social simulations, HPC applications | Professional modelers, computational scientists | Advanced Python, HPC | Optimize model performance for large-scale simulations. Deploy models in production environments. Apply ABM to real-world policy problems. |

## Mesa Framework Quick Reference

### Essential Components
- **Core Classes**: `Agent`, `Model`, `RandomActivation`, `SimultaneousActivation`
- **Spatial**: `MultiGrid`, `SingleGrid`, `ContinuousSpace`, `NetworkGrid`  
- **Data**: `DataCollector` (model/agent reporters), `BatchRunner`
- **Visualization**: `CanvasGrid`, `ChartModule`, `ModularServer`

### Key Patterns
```python
# Basic Agent Structure
class MyAgent(Agent):
    def __init__(self, unique_id, model, **kwargs):
        super().__init__(unique_id, model)
        # Initialize agent attributes
        
    def step(self):
        # Define agent behavior per time step
        pass

# Basic Model Structure  
class MyModel(Model):
    def __init__(self, **params):
        super().__init__()
        self.schedule = RandomActivation(self)
        self.grid = MultiGrid(width, height, torus=True)
        self.datacollector = DataCollector({...})
        
    def step(self):
        self.schedule.step()
        self.datacollector.collect(self)
```

### Advanced Integration
- **Networks**: `networkx` for complex topologies
- **ML**: `scikit-learn`, `tensorflow` for intelligent agents  
- **Optimization**: `numba`, `multiprocessing` for performance
- **GIS**: `geopandas`, `folium` for geographic models
- **Deployment**: Web frameworks, cloud platforms
